<?xml version="1.0" encoding="UTF-8"?>
<execute_tasks_master_protocol>

  <metadata>
    <description>Master orchestrator for Agent OS task execution with intelligent interactive
      selection</description>
    <version>6.0</version>
    <mode>IMPERATIVE_EXECUTION</mode>
    <effectiveness_target>80%+</effectiveness_target>
  </metadata>

  <pre_flight_check>
    EXECUTE: @.agent-os/instructions/meta/pre-flight.md
  </pre_flight_check>

  <!-- =======================================================================================
       INPUT PARAMETERS - Support fuzzy matching and interactive selection
       ======================================================================================= -->

  <input_parameters>
    <spec_input>
      <description>User input for spec selection - can be partial name, full path, or empty</description>
      <type>string</type>
      <required>false</required>
      <default>null</default>
      <examples>
        <empty>null â†’ prompts for selection</empty>
        <fuzzy>"quality checker" â†’ matches quality-checker-uplift</fuzzy>
        <partial>"autopilot" â†’ matches autopilot-engine</partial>
        <full>".agent-os/specs/2025-01-05-quality-checker-uplift"</full>
      </examples>
    </spec_input>

    <specific_tasks>
      <description>Optional array of specific task IDs or descriptions to execute</description>
      <type>array</type>
      <required>false</required>
      <default>null</default>
      <example>["2.2", "2.3", "2.4"]</example>
    </specific_tasks>
  </input_parameters>

  <execution_context>
    <instruction>INTELLIGENT SPEC SELECTION, THEN EXECUTE ALL PHASES</instruction>
    <interactive_selection>true when no input</interactive_selection>
    <fuzzy_matching>true for partial inputs</fuzzy_matching>
    <no_planning>true once spec selected</no_planning>
    <direct_tools_only>true</direct_tools_only>
  </execution_context>

  <!-- =======================================================================================
       SPEC SELECTION PHASE - Interactive and Intelligent
       ======================================================================================= -->

  <phase_0_spec_selection>
    <title>Spec Selection Phase</title>

    <step1_discover_specs>
      <tool>Bash</tool>
      <command>find .agent-os/specs -type d -maxdepth 1 -name "*-*" | sort -r</command>
      <description>List available spec directories</description>
    </step1_discover_specs>

    <step2_determine_input_type>
      <tool>Bash</tool>
      <command>
        if [ -z "${spec_input}" ]; then
        echo "interactive"
        elif [[ "${spec_input}" == *"/"* ]] || [[ "${spec_input}" == "."* ]]; then
        echo "path"
        else
        echo "fuzzy"
        fi
      </command>
      <description>Classify input type</description>
    </step2_determine_input_type>

    <step3a_handle_interactive>
      <condition>Previous output equals "interactive"</condition>
      <action>Display available specs from step1 and prompt for selection</action>
    </step3a_handle_interactive>

    <step3b_handle_path>
      <condition>Previous output equals "path"</condition>
      <tool>Bash</tool>
      <command>test -d "${spec_input}" && echo "${spec_input}" || echo "INVALID"</command>
      <description>Validate directory path</description>
    </step3b_handle_path>

    <step3c_handle_fuzzy>
      <condition>Previous output equals "fuzzy"</condition>
      <tool>Bash</tool>
      <command>
        input_lower=$(echo "${spec_input}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
        find .agent-os/specs -name "*${input_lower}*" -type d | head -1
      </command>
      <description>Find matching spec directory</description>
    </step3c_handle_fuzzy>

    <step4_validate_selection>
      <tool>Bash</tool>
      <command>test -d "${previous_result}" && echo "âœ… Selected spec: ${previous_result}" || echo "âŒ
        Invalid selection"</command>
      <description>Confirm final spec path exists</description>
      <store_as>SPEC_PATH</store_as>
    </step4_validate_selection>
  </phase_0_spec_selection>

  <!-- =======================================================================================
       VARIABLE INITIALIZATION - After Spec Selection
       ======================================================================================= -->

  <variable_initialization>
    <instruction>INITIALIZE EXECUTION VARIABLES AFTER SPEC SELECTION</instruction>

    <step1_load_tasks_file>
      <title>Load Tasks File</title>
      <tool>Read</tool>
      <file_path>${SPEC_PATH}/tasks.md</file_path>
      <store_as>TASK_CONTENT</store_as>
      <required>true</required>
    </step1_load_tasks_file>

    <step2_intelligent_task_selection>
      <title>Intelligent Task Selection (No Bash)</title>
      <instructions>
        ACTION: Identify task(s) to execute
        DEFAULT: Select next uncompleted parent task if not specified
        CONFIRM: Task selection with user
      </instructions>
      <store_as>TARGET_TASKS</store_as>
      <required>true</required>
    </step2_intelligent_task_selection>

    <step3_confirm_task_selection>
      <title>Confirm Task Selection</title>
      <output>
        ğŸ“‹ TASK SELECTION CONFIRMED
        â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        Spec: ${SPEC_PATH}
        Mode: ${specific_tasks ? "Specific Tasks" : "Next Parent Task"}
        Tasks to Execute: ${TARGET_TASKS}
        Total: ${COUNT(TARGET_TASKS)} tasks
      </output>
    </step3_confirm_task_selection>

    <step4_extract_folder_name>
    <tool>Bash</tool>
    <command>basename "${SPEC_PATH}"</command>
    <store_as>SPEC_FOLDER</store_as>
    <required>true</required>
    </step5_extract_folder_name>

    <completion_signal>PROCEED TO PHASE 1 WITH SELECTED TASKS</completion_signal>
  </variable_initialization>

  <!-- =======================================================================================
       PHASE 1 - PRE-EXECUTION SETUP
       ======================================================================================= -->

  <phase_1_setup>
    <title>PHASE 1 - PRE-EXECUTION SETUP</title>

    <instructions>
  <instruction>PREPARE ENVIRONMENT FOR TARGET_TASKS EXECUTION</instruction>

    </instructions>
  

    <step1_detailed_task_analysis>
      <title>Detailed Task Analysis</title>
      <cognitive_processing>
        For each task in TARGET_TASKS, extract:
        1. Task ID (e.g., "2.2")
        2. Full description
        3. Any mentioned files or components
        4. Dependencies or prerequisites
        5. Success criteria
      </cognitive_processing>
      <store_as>TASK_DETAILS</store_as>
      <output>
        ${TASK_DETAILS}
      </output>
    </step1_detailed_task_analysis>

    <step2_context_loading>
      <title>Load Relevant Context</title>
      <parallel_execution>true</parallel_execution>
      <tools>
        <tool1>
          <name>Read</name>
          <file_path>${SPEC_PATH}/spec-lite.md</file_path>
          <optional>true</optional>
        </tool1>
        <tool2>
          <name>Read</name>
          <file_path>${SPEC_PATH}/sub-specs/technical-spec.md</file_path>
          <optional>true</optional>
        </tool2>
        <tool3>
          <name>Read</name>
          <file_path>.agent-os/product/mission-lite.md</file_path>
          <optional>true</optional>
        </tool3>
      </tools>
    </step2_context_loading>

    <step3_git_setup>
      <title>Git Branch Setup via Workflow Agent - MANDATORY DELEGATION</title>
      <delegation_pattern>MANDATORY - NO BYPASS ALLOWED</delegation_pattern>
      <step3a_mandatory_delegate>
        <title>Git Workflow Delegation</title>
        <tool>Task</tool>
        <subagent_type>git-workflow</subagent_type>
        <description>Setup git branch for spec - ALWAYS delegate regardless of current branch</description>
        <prompt>
          Create feature branch for spec: ${SPEC_FOLDER}
          Just branch setup - no commits or PRs.
        </prompt>
        <mandatory>true</mandatory>
        <bypass_allowed>false</bypass_allowed>
        <wait_for_completion>true</wait_for_completion>
      </step3a_mandatory_delegate>
      <step3b_architectural_compliance_check>
        <cognitive_verification>
          VERIFY: Git workflow agent was actually invoked
          CONFIRM: No independent git decisions were made
        </cognitive_verification>
        <output>
          âœ… Git setup for task execution
          - The branch name returned from the git-workflow agent
        </output>
      </step3b_architectural_compliance_check>
    </step3_git_setup>

    <step4_todo_initialization>
      <title>Initialize Todo Tracking</title>
      <tool>TodoWrite</tool>
      <action>
        Create todo items for each task in TARGET_TASKS:
        - Use task ID and full description
        - Set all to "pending" status
        - Include activeForm for each
      </action>
    </step4_todo_initialization>

    <step5_pre_execution_checks>
      <title>Pre-execution Checks</title>
      <parallel_execution>true</parallel_execution>
      <checks>
        <wallaby_check>
          <tool>mcp__wallaby__wallaby_failingTests</tool>
          <params>{}</params>
          <optional>true</optional>
        </wallaby_check>
        <test_status>
          <tool>Bash</tool>
          <command>pnpm test --run 2>&1 | tail -5</command>
          <optional>true</optional>
        </test_status>
      </checks>
    </step5_pre_execution_checks>

    <phase1_completion>
      <output>
        âœ… PHASE 1 COMPLETE
        Ready to execute ${COUNT(TARGET_TASKS)} tasks
      </output>
      <action>PROCEED TO PHASE 2</action>
    </phase1_completion>
  </phase_1_setup>

  <!-- =======================================================================================
       PHASE 2 - TASK EXECUTION
       ======================================================================================= -->

  <phase_2_execution>
    <title>PHASE 2 - EXECUTE SELECTED TASKS</title>
    <instruction>EXECUTE EACH TASK IN TARGET_TASKS SEQUENTIALLY</instruction>

    <task_execution_loop>
      <instruction>FOR EACH TASK IN TARGET_TASKS, EXECUTE:</instruction>

      <step1_get_current_task>
        <cognitive_action>
          From TARGET_TASKS, take next unprocessed task
          Extract: task_id, task_description, task_context
        </cognitive_action>
        <store_as>CURRENT_TASK</store_as>
      </step1_get_current_task>

      <step2_announce_task>
        <output>
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          ğŸ”„ EXECUTING: Task ${CURRENT_TASK.id}
          ğŸ“ ${CURRENT_TASK.description}
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        </output>
      </step2_announce_task>

      <step3_update_todo_in_progress>
        <tool>TodoWrite</tool>
        <action>Update CURRENT_TASK status to "in_progress"</action>
      </step3_update_todo_in_progress>

      <step4_execute_task_implementation>
        <title>Execute Task Implementation</title>
        <instruction>
          Based on CURRENT_TASK.description, determine and execute required actions
        </instruction>

        <task_type_analysis>
          <analyze_task>Parse task description to identify action type</analyze_task>

          <if_type_analyze>
            <pattern>Contains: "Analyze", "Review", "Understand"</pattern>
            <actions>
              - Use Read tool to examine mentioned files
              - Use Grep tool to search for patterns
              - Document findings
            </actions>
          </if_type_analyze>

          <if_type_fix>
            <pattern>Contains: "Fix", "Update", "Modify", "Implement"</pattern>
            <actions>
              - Use Read tool to understand current state
              - Use Edit/MultiEdit tools to make changes
              - Use Bash tool to run tests
            </actions>
          </if_type_fix>

          <if_type_verify>
            <pattern>Contains: "Verify", "Test", "Ensure"</pattern>
            <actions>
              - Use Bash tool to run tests
              - Use Read tool to check outputs
              - Validate success criteria
            </actions>
          </if_type_verify>
        </task_type_analysis>

        <concrete_execution>
          Use appropriate tools based on task requirements
          Follow task description precisely
          Make incremental changes with verification
        </concrete_execution>
      </step4_execute_task_implementation>

      <step5_mark_task_complete>
        <tool>Edit</tool>
        <file_path>${SPEC_PATH}/tasks.md</file_path>
        <action>
          Find line containing CURRENT_TASK
          Change "- [ ]" to "- [x]"
        </action>
      </step5_mark_task_complete>

      <step6_update_todo_complete>
        <tool>TodoWrite</tool>
        <action>Update CURRENT_TASK status to "completed"</action>
      </step6_update_todo_complete>

      <step7_announce_completion>
        <output>
          âœ… COMPLETED: Task ${CURRENT_TASK.id}
        </output>
      </step7_announce_completion>

      <step8_continue_or_finish>
        <cognitive_check>
          IF more tasks in TARGET_TASKS:
          Continue to next task
          ELSE:
          Proceed to Phase 3
        </cognitive_check>
      </step8_continue_or_finish>
    </task_execution_loop>

    <phase2_completion>
      <output>
        âœ… PHASE 2 COMPLETE
        All ${COUNT(TARGET_TASKS)} tasks executed successfully
      </output>
      <action>PROCEED TO PHASE 3</action>
    </phase2_completion>
  </phase_2_execution>

  <!-- =======================================================================================
       PHASE 3 - POST-EXECUTION
       ======================================================================================= -->

  <phase_3_finalization>
    <title>PHASE 3 - FINALIZATION</title>
    <instruction>COMMIT CHANGES AND FINALIZE</instruction>

    <step1_run_final_tests>
      <title>Run Final Tests</title>
      <tool>Bash</tool>
      <command>pnpm test</command>
      <continue_on_failure>true</continue_on_failure>
      <store_result>TEST_STATUS</store_result>
    </step1_run_final_tests>

    <step2_commit_changes>
      <title>Commit Changes</title>
      <sequential_execution>true</sequential_execution>
      <commands>
        <add_all>
          <tool>Bash</tool>
          <command>git add -A</command>
        </add_all>
        <commit>
          <tool>Bash</tool>
          <command>git commit -m "feat: complete tasks from ${SPEC_FOLDER} Completed tasks:
            ${TARGET_TASKS} ğŸ¤– Generated with [Claude Code](https://claude.ai/code) Co-Authored-By:
            Claude <noreply @anthropic.com>"</command>
        </commit>
        <push>
          <tool>Bash</tool>
          <command>git push origin ${BRANCH_NAME}</command>
          <optional>true</optional>
        </push>
      </commands>
    </step2_commit_changes>

    <step3_update_execution_recap>
      <title>Update Execution Recap</title>
      <tool>Edit</tool>
      <file_path>${SPEC_PATH}/execution-recap.md</file_path>
      <action>
        Append new execution session with:
        - Date/time
        - Tasks completed
        - Test status
        - Branch name
      </action>
    </step3_update_execution_recap>

    <step4_final_summary>
      <output>
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ğŸ‰ EXECUTION COMPLETE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ğŸ“ Spec: ${SPEC_FOLDER}
        ğŸŒ² Branch: ${BRANCH_NAME}
        âœ… Tasks: ${COUNT(TARGET_TASKS)} completed
        ğŸ§ª Tests: ${TEST_STATUS}
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      </output>
    </step4_final_summary>

    <step5_notification>
      <tool>Bash</tool>
      <command>afplay /System/Library/Sounds/Glass.aiff 2>/dev/null || echo "ğŸ”” Done!"</command>
      <optional>true</optional>
    </step5_notification>
  </phase_3_finalization>

  <!-- =======================================================================================
       EXECUTION RULES
       ======================================================================================= -->

  <enforcement_rules>
    <rule1>MUST prompt user if no spec input provided</rule1>
    <rule2>MUST use fuzzy matching for partial spec names</rule2>
    <rule3>MUST use cognitive analysis for task selection, not bash parsing</rule3>
    <rule4>MUST default to next uncompleted parent task unless specific tasks given</rule4>
    <rule5>MUST execute only tasks in TARGET_TASKS</rule5>
    <rule6>MUST maintain task hierarchy awareness</rule6>
    <rule7>MUST update both tasks.md and TodoWrite for each task</rule7>
    <rule8>MUST execute phases sequentially</rule8>
    <rule9>MUST use concrete tool calls for implementation</rule9>
    <rule10>MUST complete all TARGET_TASKS before finishing</rule10>
    <rule11>MUST ALWAYS delegate ALL git operations to git-workflow agent - NO EXCEPTIONS regardless
      of current branch state</rule11>
    <rule12>NEVER make independent git decisions - delegation is MANDATORY architectural requirement</rule12>
  </enforcement_rules>

  <usage_examples>
    <example1>
      <input>execute-tasks-master</input>
      <behavior>Prompts user with list of available specs</behavior>
    </example1>

    <example2>
      <input>execute-tasks-master "quality checker"</input>
      <behavior>Fuzzy matches to quality-checker-uplift, selects next parent task</behavior>
    </example2>

    <example3>
      <input>execute-tasks-master ".agent-os/specs/2025-01-05-quality-checker-uplift" ["2.2", "2.3"]</input>
      <behavior>Uses exact path, executes only tasks 2.2 and 2.3</behavior>
    </example3>
  </usage_examples>

</execute_tasks_master_protocol>